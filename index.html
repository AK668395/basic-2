<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Hand-Tracked Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #video-container { position: absolute; top: 0; left: 0; z-index: 0; opacity: 0; pointer-events: none;}
        #canvas-container { position: absolute; top: 0; left: 0; z-index: 1; width: 100vw; height: 100vh; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: sans-serif; z-index: 10; }
        #instructions { position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.7); font-family: sans-serif; pointer-events: none; z-index: 5; }
    </style>
</head>
<body>
    <a href="<div data-us-project="E5dUlgYT2MDboojUsa7R" style="width:1440px; height: 900px"></div><script type="text/javascript">!function(){if(!window.UnicornStudio){window.UnicornStudio={isInitialized:!1};var i=document.createElement("script");i.src="https://cdn.jsdelivr.net/gh/hiunicornstudio/unicornstudio.js@v1.5.3/dist/unicornStudio.umd.js",i.onload=function(){window.UnicornStudio.isInitialized||(UnicornStudio.init(),window.UnicornStudio.isInitialized=!0)},(document.head || document.body).appendChild(i)}}();</script>"> Loop hole </a>
    <div id="loading">Loading models... allow camera access.</div>
    <div id="instructions">
        <p>üñêÔ∏è Move Hand X-axis: Change Color</p>
        <p>‚ÜïÔ∏è Move Hand Y-axis: Switch Shape</p>
        <p>üëå Pinch thumb & index: Expand/Contract</p>
    </div>
    <div id="video-container">
        <video class="input_video"></video>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- Configuration ---
        const PARTICLE_COUNT = 25000;
        let activeShapeIndex = 0;
        let targetShapeIndex = 0;
        let morphAlpha = 0; // 0 to 1 interpolant for morphing
        let isMorphing = false;

        // --- Three.js Variables ---
        let scene, camera, renderer, particleSystem, uniforms;
        let shapePositions = []; // Array to hold Float32Arrays for different shapes

        // --- MediaPipe Variables ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        let handInteractionData = {
            pinchDistance: 0.5, // 0 to 1 normalized
            handPosX: 0.5, // 0 to 1 normalized
            handPosY: 0.5 // 0 to 1 normalized
        };

        // ==========================================
        // --- Step 1: Define Shape Math Functions ---
        // ==========================================

        function getSphere(count, radius) {
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const phi = Math.acos(-1 + (2 * i) / count);
                const theta = Math.sqrt(count * Math.PI) * phi;
                positions[i * 3] = radius * Math.cos(theta) * Math.sin(phi);
                positions[i * 3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
                positions[i * 3 + 2] = radius * Math.cos(phi);
            }
            return positions;
        }

        function getHeart(count, scale) {
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const t = (i / count) * Math.PI * 2;
                // Basic 2D heart extrusion
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                const z = (Math.random() - 0.5) * 10; // Add depth
                
                positions[i*3] = x * scale;
                positions[i*3+1] = y * scale;
                positions[i*3+2] = z * scale;
            }
            return positions;
        }

        function getSaturn(count, radius) {
             const positions = new Float32Array(count * 3);
             const planetCount = Math.floor(count * 0.4);
             const ringCount = count - planetCount;
             
             // Planet Sphere
             for(let i = 0; i < planetCount; i++) {
                const phi = Math.acos(-1 + (2 * i) / planetCount);
                const theta = Math.sqrt(planetCount * Math.PI) * phi;
                positions[i * 3] = radius * 0.6 * Math.cos(theta) * Math.sin(phi);
                positions[i * 3 + 1] = radius * 0.6 * Math.sin(theta) * Math.sin(phi);
                positions[i * 3 + 2] = radius * 0.6 * Math.cos(phi);
             }

             // Rings (Disc)
             for(let i = planetCount; i < count; i++) {
                 const r = radius * (1.2 + Math.random() * 0.8);
                 const theta = Math.random() * Math.PI * 2;
                 positions[i*3] = r * Math.cos(theta);
                 positions[i*3+1] = (Math.random() - 0.5) * radius * 0.1; // Slight thickness
                 positions[i*3+2] = r * Math.sin(theta);
             }
             return positions;
        }

        function getSpiral(count, scale) {
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const t = i / count;
                const angle = t * Math.PI * 20; // 10 rotations
                const radius = t * scale;
                positions[i * 3] = radius * Math.cos(angle);
                positions[i * 3 + 1] = (t - 0.5) * scale * 2; // Height
                positions[i * 3 + 2] = radius * Math.sin(angle);
            }
            return positions;
        }

        // ==========================================
        // --- Step 2: Three.js Setup & Shaders ---
        // ==========================================

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 150;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // --- Pre-calculate Shapes ---
            shapePositions.push(getSphere(PARTICLE_COUNT, 50));     // Index 0
            shapePositions.push(getHeart(PARTICLE_COUNT, 2.5));     // Index 1
            shapePositions.push(getSaturn(PARTICLE_COUNT, 40));     // Index 2
            shapePositions.push(getSpiral(PARTICLE_COUNT, 80));     // Index 3

            // --- Geometry Setup ---
            const geometry = new THREE.BufferGeometry();
            // Initialize position with the first shape
            geometry.setAttribute('position', new THREE.BufferAttribute(shapePositions[0].slice(), 3));
            // Initialize target position (same as start initially)
            geometry.setAttribute('targetPosition', new THREE.BufferAttribute(shapePositions[0].slice(), 3));
            
            const initialColors = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT; i++) {
                initialColors[i*3] = 0.5 + Math.random()*0.5;
                initialColors[i*3+1] = 0.5 + Math.random()*0.5;
                initialColors[i*3+2] = 1.0;
            }
            geometry.setAttribute('baseColor', new THREE.BufferAttribute(initialColors, 3));


            // --- Shader Material Setup ---
            uniforms = {
                uTime: { value: 0.0 },
                uPinchScale: { value: 1.0 },
                uHueShift: { value: 0.0 },
                uMorphFactor: { value: 0.0 }
            };

            // Vertex Shader: Handles position morphing and scaling
            const vertexShader = `
                uniform float uTime;
                uniform float uPinchScale;
                uniform float uMorphFactor;
                
                attribute vec3 targetPosition;
                attribute vec3 baseColor;
                
                varying vec3 vColor;
                varying float vDepth;

                // simplex noise function (condensed for brevity)
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) { 
                    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i  = floor(v + dot(v, C.yyy) );
                    vec3 x0 = v - i + dot(i, C.xxx) ;
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min( g.xyz, l.zxy );
                    vec3 i2 = max( g.xyz, l.zxy );
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.xxx;
                    vec3 x3 = x0 - 1.0 + C.xxx;
                    i = mod289(i); 
                    vec4 p = permute( permute( permute( 
                                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                    float n_ = 0.142857142857; 
                    vec3  ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); 
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_ ); 
                    vec4 x = x_ *ns.x + ns.yyyy;
                    vec4 y = y_ *ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4( x.xy, y.xy );
                    vec4 b1 = vec4( x.zw, y.zw );
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                    p0 *= norm.x;
                    p1 *= norm.y;
                    p2 *= norm.z;
                    p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                                dot(p2,x2), dot(p3,x3) ) );
                }

                void main() {
                    vColor = baseColor;
                    
                    // Morphing interpolation
                    vec3 morphedPos = mix(position, targetPosition, uMorphFactor);
                    
                    // Add some noise movement so they aren't totally static
                    float noiseVal = snoise(vec3(morphedPos.x * 0.05, morphedPos.y * 0.05, uTime * 0.5));
                    morphedPos += normalize(morphedPos) * noiseVal * 5.0;

                    // Apply pinch scaling expansion
                    vec3 finalPos = morphedPos * (0.5 + uPinchScale * 2.0); // Scale from 0.5x to 2.5x
                    
                    vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                    vDepth = -mvPosition.z;

                    // Size attenuation based on depth
                    gl_PointSize = 3.0 * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;

            // Fragment Shader: Handles coloring based on hand X position
            const fragmentShader = `
                uniform float uHueShift;
                varying vec3 vColor;
                varying float vDepth;

                // HSV to RGB helper function
                vec3 hsv2rgb(vec3 c) {
                    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                }

                void main() {
                    // Create a circle shape for the point
                    if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.475) discard; 

                    // Convert base RGB color to HSV, shift Hue, convert back
                    // Simple approximation for demo: shift red channel based on hand X
                    vec3 shiftedColor = vColor;
                    
                    // Apply hue shift based on hand X position
                    vec3 hsv = vec3(uHueShift, 0.8, 0.9); // Use Hand X as hue
                    shiftedColor = hsv2rgb(hsv);

                    // Make particles further back slightly darker
                    shiftedColor *= smoothstep(200.0, 50.0, vDepth);

                    gl_FragColor = vec4(shiftedColor, 1.0);
                }
            `;

            const material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthTest: false,
                blending: THREE.AdditiveBlending // Glow effect
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==========================================
        // --- Step 3: MediaPipe Hands Integration ---
        // ==========================================

        function onResults(results) {
             document.getElementById('loading').style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // --- 1. Pinch Distance (Thumb tip vs Index tip) ---
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                // Simple 2D distance for speed
                const dx = thumbTip.x - indexTip.x;
                const dy = thumbTip.y - indexTip.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                // Normalize distance approx 0.02 (closed) to 0.25 (open) -> 0 to 1
                handInteractionData.pinchDistance = Math.min(Math.max((distance - 0.02) / 0.2, 0), 1);

                // --- 2. Hand Position X (Use wrist or palm center) ---
                // MediaPipe x is 0 (left) to 1 (right). Flip it for intuitive interaction.
                handInteractionData.handPosX = 1.0 - landmarks[9].x; 

                // --- 3. Hand Position Y (Shape Switching) ---
                // MediaPipe y is 0 (top) to 1 (bottom).
                handInteractionData.handPosY = 1.0 - landmarks[9].y;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // 0 for fastest, 1 for accurate
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraMP = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraMP.start();


        // ==========================================
        // --- Step 4: Main Animation Loop ---
        // ==========================================

        function updateMorphing(deltaTime) {
            if (!isMorphing) {
                // Determine target shape based on hand Y position
                const numShapes = shapePositions.length;
                // Map Y (0-1) to shape index slots
                let newTargetIndex = Math.floor(handInteractionData.handPosY * numShapes);
                newTargetIndex = Math.min(newTargetIndex, numShapes - 1);

                if (newTargetIndex !== activeShapeIndex) {
                    targetShapeIndex = newTargetIndex;
                    
                    // Prepare geometry for morphing
                    const geom = particleSystem.geometry;
                    // Set current positions equal to what the shader is currently showing
                    // (This is a simplification. Ideally we'd bake the morph state, but for simple transitions: )
                    // We set the 'position' attribute to the OLD shape data
                    geom.attributes.position.array.set(shapePositions[activeShapeIndex]);
                    geom.attributes.position.needsUpdate = true;

                    // Set the 'targetPosition' attribute to the NEW shape data
                    geom.attributes.targetPosition.array.set(shapePositions[targetShapeIndex]);
                    geom.attributes.targetPosition.needsUpdate = true;

                    isMorphing = true;
                    morphAlpha = 0;
                }
            } else {
                // Continue morphing animation
                morphAlpha += deltaTime * 2.0; // Morph speed
                if (morphAlpha >= 1.0) {
                    morphAlpha = 1.0;
                    isMorphing = false;
                    activeShapeIndex = targetShapeIndex;
                }
                uniforms.uMorphFactor.value = morphAlpha;
            }
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            uniforms.uTime.value += deltaTime;

            // Update uniforms from hand data with smoothing for less jitter
            uniforms.uPinchScale.value += (handInteractionData.pinchDistance - uniforms.uPinchScale.value) * 0.1;
            uniforms.uHueShift.value += (handInteractionData.handPosX - uniforms.uHueShift.value) * 0.1;

            updateMorphing(deltaTime);

            // Slight rotation for visual interest
            particleSystem.rotation.y += 0.005 * deltaTime;
            particleSystem.rotation.z += 0.002 * deltaTime;

            renderer.render(scene, camera);
        }

        // Start
        initThreeJS();
        animate();

    </script>
</body>
</html>
